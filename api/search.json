[{"id":"1376fd1e41b2762f69b9db15721437ab","title":"hexo常用命令","content":"\n\n\n\n\n\n\n常用的 Hexo 指令：\n\nhexo init &lt;folder&gt; - 在指定目录创建一个新的 Hexo 站点。\nhexo new &lt;title&gt; - 创建一篇新的文章。例如：hexo new &quot;Hello World&quot; 将创建一篇名为 &quot;Hello World&quot; 的新文章。\nhexo generate 或 hexo g - 生成静态文件。\nhexo server 或 hexo s - 启动本地服务器，用于预览博客。默认情况下，访问地址是 http:&#x2F;&#x2F;localhost:4000。\nhexo deploy - 部署博客到远程服务器或托管平台。\nhexo clean - 清除生成的静态文件。\nhexo publish &lt;title&gt; - 发布草稿文章。\nhexo new page &lt;title&gt; - 创建新页面。\nhexo generate --deploy 或 hexo g -d - 生成静态文件并立即部署。\nhexo new &lt;layout&gt; &lt;title&gt; - 创建特定布局的文章或页面。\nhexo list &lt;type&gt; - 列出文章或草稿。\nhexo open - 在默认浏览器中打开博客。\nhexo version - 显示 Hexo 版本信息。\n这只是 Hexo 常用指令的一部分，可以使用 hexo --help 或 hexo \\&lt;command&gt; --help 来获取更多帮助信息。\n\n\n\n","slug":"hexo常用命令","date":"2023-09-19T12:16:59.000Z","categories_index":"hexo","tags_index":"hexo","author_index":"伽啵"},{"id":"4244050a23e44ddc4e0428111ab85204","title":"unbuntu常用命令","content":"\n\n\n\n\n\n\nubuntu命令行常用指令:\n\n一些常用的 Ubuntu 命令：\n\ncd - 切换目录\n例如：cd &#x2F;home&#x2F;user&#x2F;Documents\n\nls - 列出目录内容\n例如：ls\n\nmkdir - 创建新目录\n例如：mkdir new_directory\n\ntouch - 创建新文件\n例如：touch new_file.txt\n\nrm - 删除文件或目录\n例如：rm file.txt 或 rm -r directory\n\ncp - 复制文件或目录\n例如：cp source_file destination\n\nmv - 移动文件或重命名文件\n例如：mv old_name new_name 或 mv file &#x2F;path&#x2F;to&#x2F;directory\n\nnano (或其他文本编辑器) - 编辑文件\n例如：nano file.txt\n\ncat - 查看文件内容\n例如：cat file.txt\n\ngrep - 在文件中搜索文本\n例如：grep &quot;pattern&quot; file.txt\n\napt-get - 系统更新和软件安装\n例如：sudo apt-get update 和 sudo apt-get install package_name\n\nwget - 下载文件\n例如：wget http:&#x2F;&#x2F;example.com&#x2F;file.zip\n\ntar - 解压缩文件\n例如：tar -zxvf file.tar.gz\n\nsudo - 以管理员权限运行命令\n例如：sudo command\n\nchown - 修改文件或目录的所有者\n例如：sudo chown user:group file.txt\n\nchmod - 修改文件或目录的权限\n例如：chmod 755 file.txt （给所有者读写执行权限，给组和其他用户读和执行权限）\n\nps - 查看当前运行的进程\n例如：ps aux\n\nkill - 终止进程\n例如：kill PID\n\ndf - 查看磁盘使用情况\n例如：df -h\n\nfree - 查看内存使用情况\n例如：free -h\n\npwd - 显示当前工作目录的路径。\n例如：pwd\n\nuname - 显示系统信息。\n例如：uname -a\n\ntop - 实时显示系统性能情况。\n例如：top\n\nwho - 显示当前登录用户的信息。\n例如：who\n\ndu - 显示目录的磁盘使用情况。\n例如：du -h\n\nfind - 在文件系统中搜索文件。\n例如：find &#x2F; -name file.txt\n\nsort - 对文件内容进行排序。\n例如：sort file.txt\n\nawk - 强大的文本处理工具。\n例如：awk &#39;&#123;print $1&#125;&#39; file.txt\n\nsed - 流编辑器，用于对文本进行替换和编辑操作。\n例如：sed &#39;s&#x2F;old&#x2F;new&#x2F;&#39; file.txt\n\nping - 测试与另一台计算机的连接。\n例如：ping google.com\n\ntraceroute - 显示数据包从本地到目标主机的路径详细信息。\n例如：traceroute google.com\n\nifconfig - 显示和配置网络接口信息。\n例如：ifconfig\n\nnetstat - 显示网络连接、路由表和网络接口信息。\n例如：netstat -an\n\nssh - 远程登录到其他主机。\n例如：ssh user@host\n\nscp - 安全地将文件复制到远程主机。\n例如：scp file.txt user@host:&#x2F;path\n\nwget - 从网络下载文件。\n例如：wget http:&#x2F;&#x2F;example.com&#x2F;file.zip\n\nhistory - 查看历史命令记录。\n例如：history\n\nnohup - 让程序在后台运行，不受终端关闭影响。\n例如：nohup command &amp;\n\ncrontab - 设置定时任务。\n例如：crontab -e\n\nalias - 创建命令别名。\n例如：alias ll&#x3D;&#39;ls -l&#39;\n\n\n","slug":"unbuntu常用命令","date":"2023-09-19T12:01:23.000Z","categories_index":"Ubuntu,linux","tags_index":"Ubuntu,linux","author_index":"伽啵"},{"id":"713afdeed1c1908fb0df299487bbf254","title":"HttpServletRequest和HttpServletResponse用法","content":"HttpServletRequest 和 HttpServletResponse 是 Java Servlet 技术中的两个重要对象，用于处理HTTP请求和响应。下面我会分别介绍它们的使用方法：\n\n\n\n\n\n\nHttpServletRequest\nHttpServletRequest 代表了客户端发来的HTTP请求，包含了请求的各种信息，例如请求的URL、HTTP方法、请求头、请求参数等。以下是一些常见的使用方式：\n&#x2F;&#x2F;获取请求方法（GET、POST等）：String method &#x3D; request.getMethod();\n&#x2F;&#x2F;获取请求URL：StringBuffer url &#x3D; request.getRequestURL();\n&#x2F;&#x2F;获取请求参数：    &#x2F;&#x2F; 获取单个参数    String paramName &#x3D; request.getParameter(“paramName”);    &#x2F;&#x2F; 获取多个值的参数    String[] values &#x3D; request.getParameterValues(“paramName”);\n&#x2F;&#x2F;获取请求头信息：String userAgent &#x3D; request.getHeader(“User-Agent”);\n&#x2F;&#x2F;获取Session对象：HttpSession session &#x3D; request.getSession();\n&#x2F;&#x2F;获取客户端的IP地址：String ipAddress &#x3D; request.getRemoteAddr();\n&#x2F;&#x2F;获取请求的路径信息：String pathInfo &#x3D; request.getPathInfo();\n\n\n\n\n\n\n\n\nHttpServletResponse\nHttpServletResponse 代表了服务器向客户端发送的HTTP响应，允许你设置响应的状态码、响应头和响应体。以下是一些常见的使用方式：\n&#x2F;&#x2F;设置响应状态码：response.setStatus(HttpServletResponse.SC_OK); &#x2F;&#x2F; 设置为200 OK\n&#x2F;&#x2F;设置响应头：response.setHeader(“Content-Type”, “text&#x2F;html; charset&#x3D;UTF-8”);\n&#x2F;&#x2F;写入响应体：PrintWriter out &#x3D; response.getWriter();out.println(“Hello, World!“);\n&#x2F;&#x2F;重定向：response.sendRedirect(“&#x2F;newPage.jsp”);\n&#x2F;&#x2F;设置Cookie：Cookie cookie &#x3D; new Cookie(“username”, “John”);response.addCookie(cookie);\n&#x2F;&#x2F;设置缓存控制：response.setHeader(“Cache-Control”, “no-cache, no-store, must-revalidate”);response.setHeader(“Pragma”, “no-cache”);response.setDateHeader(“Expires”, 0);\n\n这些是 HttpServletRequest 和 HttpServletResponse 的一些常见用法。它们用于在Java Servlet中处理HTTP请求和响应，允许你构建动态的Web应用程序。根据你的需求，你可以根据具体情况使用它们的不同方法来处理和操作HTTP请求和响应。","slug":"HttpServletRequest和HttpServletResponse用法","date":"2023-09-03T11:39:55.000Z","categories_index":"SpringMVC,HttpServletRequest,HttpServletResponse","tags_index":"Springboot,HttpServletRequest,HttpServletResponse,SpringMVC","author_index":"伽啵"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-09-03T02:32:24.363Z","categories_index":"","tags_index":"","author_index":"伽啵"},{"id":"b7ab690037a7c2d44c2d4405477467f3","title":"sql注入入门","content":"\n\n\n\n\n\n 1.什么是sql注入\nSQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。\n\n\n\n\n\n\n\n\n\n2.常见数据库端口号\n    关系型数据库：        1.Oracle数据库默认端口号为，1521；        2.MySQL数据库默认端口号为，3306；        3.SQLServer数据库默认端口号为，1433;        4.postgreSQL数据库默认端口号为，5432;    NOSQL数据库：        1.MongoDB默认端口号为：27017；        2.Redis默认端口号为：6379；        3.memcached默认端口号为：11211；\n\n\n\n\n\n\n\n\n常用的函数有:\nversion(),user(),database(),@@version_complie_os\ngroup_concat(table_name);&#x2F;&#x2F;主要用来将查询到的表全部拼接\t\ninformation_schema主要用的表有TABLES和SCHEMAS，列有CLOUNM_NAME,TABLE_NAME,SCHEMA_NAME\n\n\n\n\n\n\n\n\n\n3.sql注入有哪些\nhttp-head注入json注入联合注入编码解码注入加密解密注入\n报错注入\n*floor函数\n\tfloor和count和group by三个函数在一起会产生报错。\n\t语句：select * from aaa where id&#x3D;1 and (select 1 from \n\t\t(select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);\n\n*extractValue函数\n\t*原理和updatexml一样。\n\t*语句：select * from aaa where id&#x3D;1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));\n*updatexml函数\n\t*updatexml(XML_document, XPath_string, new_value);\n\n\t简单来说就是updatexml(目标xml内容,xml文档路径,更新的内容)\n\t我们在xml文档路径的位置写入了子查询，和特殊字符拼接在一起，因为不符合输入路径规则然后报错，\n\t先执行了子查询我们可以得到库名。0x7e是16进制里面的“~”，是一个特殊符号，不符合路径规则报错\n\t语句：select &#39;*&#39; from aaa where id&#x3D;1 and updatexml(1,concat(0x7e,(select user()),1)\n布尔注入\n利用场景：有些网站没有输出点，且关闭了错误回显，但明显的返回true或者false。\t\n\t这里以mysql为例，需要用到的几个函数。\n\tlength()：函数的返回值为字符串的字节长度。\n\tsubstr()：截取字符串，用法substr(string, start,length)\n\tstring-指定的要截取的字符串  start-规定在字符串的何处开始 length-指定要截取的字符串长度\n\tascii()：返回字符串中第一个字符的ascii值\n\t1：使用length()函数猜数据库名长度\n\t\t如length(database())&gt;10,页面显示正常。\n\t\tlength(database())&gt;20,页面显示不正常。\n\t\tlength(database())&#x3D;9,页面显示正常。\n\t我们可以用二分法猜解得到数据库的长度。\n\t2：利用ascii猜数据库名\n\t\tand (ascii(substr(database(),1,1)))&#x3D;100,如果页面返回正常，说明数据库名称第一位是d\n\t3：猜字段名\n\t\tand (ascii(substr((select column_name from \n\t\tinformation_schema.columns where table_name&#x3D;&#39;aaa&#39; limit 0,1),1,1)))&gt;100\n\n延时注入\n有时候我们会遇到一种情况，无论怎么操作页面都是返回正常，这时我们可以考虑用延时注入。\n\n这里用mysql举例，需要用到两个函数。\nsleep()：执行挂起一段时间,也就是等待一段时间在继续执行。\n例：select  * from  users where id&#x3D;1 and sleep(5);   &#x2F;* 5秒之后执行SQL语句*&#x2F;\nif(expr1,expr2,expr3)：expr1为0或者null或者false，则返回 expr3 ; 否则，返回expr2。\n构造语句：and if(ascii(substr(database(),1,1))&#x3D;100,0,sleep(10))\n如果库名第一个字符是d，则网页延时10秒。\n宽字节注入\n原理：\n\t如果程序设计数据库编码的时候设置了非英文编码，php发送请求到mysql时经过一次gbk编码，因为gbk是双字节编码，\n\t当设置gbk编码后，遇到了连续两个字节都符合gbk取值范围，会自动解析成一个汉字，输入%df%27，本来\\会转义%27（’）,\n\t但\\（%5c）的编码数为92，%df的编码数为223，符合取值范围，于是%df%5c会解析成为一个汉字“運”，单引号就逃逸了出来，\n\t从而绕过转义造成注入。\n\n\t注：1.POST注入并不会进行URL转码，所以需要改hex。\n\t2.在查询时用到的表名字段名不能用原来的‘admin’形式，这时候可以转换十六进制，或者用子查询。\n\t3.还可以用汉字绕过。\n\ndnslog注入\n在某些无法直接利用漏洞获得回显时如果用盲注来做效率低下且容易被waf拦截，但是目标可以发起请求，这个时候我们\n可以通过DNS解析把我们想要获得的数据外带出来。\n注入过程：通过子查询将内容拼接到域名内，让load_file()去访问共享文件，访问的域名被记录，读取远程共享文件，\n通过拼接出函数做查询，\n拼接到域名中，访问时将访问服务器，记录后查询该日志。\n\n这里需要用到一个mysql函数LOAD_FILE()：读取一个文件并将其内容作为字符串返回。\nLOAD_FILE(file_name)，file_name是文件的完整路径。\n要使用这个函数，需要满足下面三个条件：\n\t文件必须位于服务器主机上\n\t必须指定完整路径的文件，且必须有FILE权限。\n\t该文件所有字节可读，但文件内容必须小于max_allowed_packet(限制server接受的数据包大小函数，默认1MB)。\n\t该功能不是默认开启的，需要在mysql配置文件加上一句secure_file_priv&#x3D;&#39;&#39;\n\n偏移注入\n   使用sql注入的时候，我们会遇到一些无法查询表名字段名的时候，比如access数据库没有系统自带库。\n使用场景：当你猜到表名但是无法猜到字段名的情况下可以使用。\n以access数据库为例，假设我们已经通过爆破得到我们要查询的表名为admin\n1.判断字段：\n\t用order by判断一共有15个字段\n2.爆出显示位：\n\tunion select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 from admin\n\t假设输出点在3,4,5\n3.偏移注入判断admin表里的字段数为6\n\tunion select 1,2,3,4,5,6,7,8,9,10,11,12,*,14,15 from admin 页面报错\n\tunion select 1,2,3,4,5,6,7,8,9,* from admin 页面正常\n\t*等价于admin.* 表示admin表里面的所有字段\n4.获取字段名\n\t我们假设admin里面的6个字段为a，b，c，d，e，f\n\tunion select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 from admin\n\t等价为union select 1,2,3,4,5,6,7,8,9, * from admin\n\t因为输出点在3,4,5那么union select 1,2, *,9,10,11,12,13,14,15 from admin\n\t是不是等于union select 1,2,a,b,c,d,e,f,9,10,11,12,13,14,15 from admin\n\t那么我们就可以得到a，b，c的数据\n\t我们可以继续移动位置union select 1,admin.*,8,9,10,11,12,13,14,15 from admin\n\t这样我们就可以的b，c，d的数据，但是我们怎么也无法得到f的数据，所以偏移注入也是有局限的，\n\t原本要查询的字段数越多，输出点越多，就越有利。\n二次注入\n二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入。\n二次注入是sql注入的一种，但是比普通sql注入利用更加困难，利用门槛更高。普通注入数据直接进\n入到 SQL 查询中，而二次注入则是输入数据经处理后存储，取出后，再次进入到 SQL 查询。\n\n原理:\n\t在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc \n\t对其中的特殊字符进行了转义，\n\t在后端代码中可能会被转义，但在存入数据库时还是原来的数据，数据中一般带有单引号和＃号，\n\t然后下次使用在拼凑SQL中，所以就形成了二次注入。\n\n过程:\n\t插入1‘#\n\t转义成1\\’#\n\t不能注入，但是保存在数据库时变成了原来的1’#\n\t利用1’#进行注入,这里利用时要求取出数据时不转义\n\t\n换言之, 二次注入需要具备的两个条件：\n\t（1）用户向数据库插入恶意语句（即使后端代码对语句进行了转义，\n\t\t 如mysql_escape_string、mysql_real_escape_string转义）\n\t（2）数据库对自己存储的数据非常放心，直接取出恶意数据给用户\n堆叠注入\nStacked injections(堆叠注入)从名词的含义就可以看到应该是一堆 sql 语句(多条)一起执行。\n而在真实的运用中也是这样的, 我们知道在 mysql 中, 主要是命令行中, 每一条语句结尾加;\n表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做 stacked  injection。\n\n堆叠注入原理\n\t在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？\n\t因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？\n\t区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。\n\t用户输入：1; DELETE FROM products服务器端生成的sql语句为： Select * from products where productid&#x3D;1;DELETE FROM products当执行查询后，\n\t第一条显示查询信息，第二条则将整个表进行删除。\n\n堆叠注入的局限性\n\t堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，\n\t当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。\n\n\n","slug":"sql注入入门","date":"2023-09-03T01:18:09.000Z","categories_index":"sql注入","tags_index":"sql注入,web安全,入门","author_index":"伽啵"},{"id":"b8293080b39b799f8a79ba4eca1cf5d4","title":"须知","content":"\n\n\n\n\n\n\nZSQ死卷逼我孙子,CS榜首\n\n\n","slug":"须知","date":"2023-09-02T11:28:09.000Z","categories_index":"","tags_index":"须知","author_index":"伽啵"}]